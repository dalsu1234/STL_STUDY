/*

STL의 대표종류

Container
Iterator
Algorithm




Container와
Iterator
는 자료구조


Algorithm
알고리즘 과 관련있는것

####################################################

수많은 Container 가  있는데 
이 여러 컨테이너들이 어떤 구조를 가지고 있는지에대해 알아야한다


Container

대표적인 구조


	- Sequence Container : 순자 컨테이너
		
		순차컨테이너의 대표적인 종류

		1. std::array	: 정적배열

		2. std::vector	: 동적배열 가변배열
		
		3. std::list (Double Linked List)
		
		4. std::forward_list (Single Linked List)
		
		5. std::deque (Double Ended Queue) : 양방향에서 데이터가 날수있는 Queue


	- Container Adaptor : 보조 컨테이너
		
		특정한 목적을 가지고 있는
		일반적인 사용법을 가지고 있는 컨테이너를 변형해서 사용하는

		대표적인 종류

		1. std::stack

		2. std::queue

		3. std::priority_queue  : 우선순위 queue 우선순위가 높은원소부터 빠져나가는 구조


	- Associative Container : 연관 컨테이너
		
		대표적인 종류

		1. std::set
		2. std::map
		3. std::multiset
		4. std::multimap


	컨테이너는 이외에 여러가지종류가 더있고
	필요에따라 새롭게 구조를 만들어서 사용하는경우도 있다

############################################################################

	복잡도
	Complecity
	성늠의 측정이 가능
	
	복잡도에 영향을 주는걸 오버헤드라고 한다

	OverHead(간접비용)
	- 실제 컨테이너의 원소에 대한 복잡도가 아니라
	컨테이너를 구성하기위해 추가 구성하는것을 오버헤드라 한다

	예를들어

	int arr[4];
	는 그냥 인트형 4개의 원소를 가지고있으면되니
	총 16바이트에 크기가 필요하다

	하지만 링크드 리스트같은 구조로 똑같이 만들자면

	한노드에 원소를 담는 int형 변수가 하나 필요하고
	그리고 그다음 노드를 가르키는 포인터형 변수가 필요할것이다

	그러면 한 노드당 4바이트가 아닌 8바이트가 필요할텐데
	(총 32바이트)

	위에 단순 배열이랑 비교할때 용량이 더 필요하니깐

	이 부분을 오버헤드라 한다

	즉 컨테이너를 구성하기위해 추가 구성하는것이
	링크드 리스트에선 자기자신의 타입인 포인터변수가 오버헤드


	오버헤드는 공간 복잡도에 관한것이라면

	시간복잡도는 Access Time (접근시간)이라 한다

	원소에 접근할때 얼마나 빠르냐를 측정



	Access Time
		- RAM, HDD

		1. Random Access (임의 접근)
			대표적으로 RAM
			원하는 원소를 바로 접근가능


		2. Sequential Access (순차 접근)
			대표적으로 HDD
			원하는 원소를 찾기위해 원소들을 순회하면 접근


############################################################################################



std::array
	- Sequence Container : 순차 컨테이너
	- Contiquos : 연속된 메모리 공간
	- Fixed Size : 고정 크기
	- 배열 대신 사용

	표현식>
	예
	std::array<int, 4> intArray{0,1,2,3};
	<int, 4> 타입의 크기와, 배열의 크기

	예제>>
##################################################################################

#include <iostream>
#include <array> // array 라이브러리가 필요

int main()
{
	std::array<int, 4> intArray{0,1,2,3};

	intArray.empty();

	intArray.fill(const value_type & __u);
	
	//
	for (const auto& e : intArray)
	{
		std::cout << e << std::endl;
	}


	//
	std::array<int, 4>::iterator itr = intArray.begin();
	for (;itr != intArray.end();itr++)
	{
		std::cout << *itr << std::endl;
	}


	//
	for (int i = 0; i < intArray.size(); i++)
	{
		std::cout << intArray[i] << std::endl;
	}
}


##################################################################################




	intArray.empty();
	
	기능
	배열안의 값이 비어있는지 아닌지 참거짓으로 확인

	
	intArray.fill(const value_type & __u)
	
	매개변수 const value_type & __u 은
	const 상수 vlaue_type 타입 & 참조 인 변수
	상수형 참조니깐 우측값도 받아준다
	우측값참조

	기능
	배열의 모든원소를 4로 채워준다
################################################################################


std::vector

	- Sequential 순차적 컨테이너

	- Contiguous    / Allocator
연속적인 메모리공간 / 상황에따라 동적으로 할당할수있다

	- Dynamic Size
		동적 사이즈

	- 동적배열 - 뒤에 원소가 추가되거나 삭제되는 경우
	 원소의 추가 / 삭제가 뒤에서 일어날때


==============================================================

	이미 만들어진 동적배열을 현재 크기보다 줄이려면
	동적배열을 다시 만들어서 옮긴후
	기존 메모리 지우고
	복사대입

	굉장히 비효율적
	기능적으로 안되는건 아닌데 너무 비효율적이라
	
	크기를 줄이는건 과정자체가 이렇게 복잡하다
	
	그래서 크기를 키우는건 
	마지막 원소뒤에 새로만드는 원소를 붙여주기만 하면된다
	하지만 동적배열이라
	만약 3개의 크기의 동적배열을 4개로 늘리려면 늘릴수야 있긴한데
	늘리고자하는 4번째공간에
	만약 이미 자리잡고있는 메모리공간이 있다면??

	결국 다시 동적배열하고 다시 대입복사를 해줘야하는과정을 거친다
	이거를 오버헤드라 하는데
	이런 오버헤드가 안일어나기위해
	뒤에 원소가 추가되거나 삭제되는경우만 사용하자
	
	메모리 침범하게되는경우는 어쩔수없지
	새로운 동적배열후에 복사대입해야하는 
	오버헤드가 일어나는건 어쩔수없지머

################################################################################



Container.push_back(4);
맨뒤에 원소를 추가하는기능

Container.pop_back();
맨뒤에 있는 원소를 제거하는 기능


Container.erase(Container.begin()); 
이런식은 오버헤드가 발생한다

Container.resize(3);
동적배열의 크기를 줄이는 기능 
이것도 오버헤드가 발생

Container.resize(3, 0);
컨테이너 크기를 정하는 매개변수 뒤에 숫자가 의미하는건
기존 컨테이너의 크기를 넘어서 커진다면
그남는 공간에 기본값을 0으로 만들어준다
컨테이너의 빈칸에 해당숫자로 채워준다


Container.clear();
모든 원소를 싹 지우는 기능


- std::array와 같은 정적배열은
resize나 clear 같은 기능들이 안된다
왜냐 정적이니깐
컴파일 불가능
이래서 각 컨테이너 구조를 알아야함





##################################################################################


std::forward_list
	
	- Sequential 원소는 정해진 순서대로 저장된다 // 순차적

	- single linked list // 이 이유때문에 배열첨자가 사용이 불가능하다

	- 연속된 메모리를 차지하진않는다

	- 동적

	벡터와 같이
	중간에 원소를 삽입할수는 있지만 
	원소의 추가/삭제가 뒤에서 일어날때가 가장 빠르다
	벡터보다는 추가/삭제가 자유롭다
	리스트

!!!리스트는 배열첨자 사용이 불가능하다

연속된 공간에 있어야만 배열첨자 사용이 가능해진다
각 노드들이 메모리에 따로 저장되어있잔여


#######################################################################
예제


std::forward_list<int> Container {0,1,2,3};
선언

forward 리스트는 사이즈를 구할수가 없다
알고리즘을 사용해서 구해야한다 제공하는 기능이 없다

원소를 순회하면서 갯수를 세는수밖에 없다
한땀한땀 세는수밖에




#특정 원소를 찾는 기능 

std::forward_list<int>::iterator itr = std::find(Container.begin(), Container.end(), 11);



#auto 를 사용해서 줄일수도 있다

auto itr = std::find(Container.begin(), Container.end(), 11);

---------------------------------------------------------------------------------

해석..

찾고자 하는 범위 
Container.begin(), Container.end() 

그 범위에서 
11 이라는 값을 찾겠다라는 뜻



std::forward_list<int>::iterator itr = 
이건 무슨뜻이냐면
컨테이너에는 값을 저장하는 변수가 있고
힙에 저장된 동적 공간을 가르키는 포인터변수 이터레이터가 있는데

find라는 기능으로 원하는 메모리 공간의 주소값을 받아서

나중에 그주소로 다른기능을 쓰기위해 itr이라는 변수에 주소값을 넣어주는
뭐 그런거다 그 컨테이너의 포인터 변수 타입을 제대로 맞춰줘야하니깐


이받은 주소값으로 여러가지 할수있는데

------------------------------------------------------------------------------

끼워넣기

Container.insert_after(itr, 12);

아까 find()에서 주소값을 받은 itr로 위치잡고
그노드 뒤에 12라는 값을 끼워넣겠다라는것


노드 삭제

Container.erase_after(itr);

itr로 받은 주소값이 가르키고 있는 노드를 삭제하는 기능



------------------------------------------------------------

Container.sort();  // 컨테이너 형태

std::sort(Container.begin(), Container.end()); // 알고리즘 형태

인데
이 구조는 링크드 리스트 구조이기때문에 
std::sort는 사용할수가없다
이유는 메모리 공간에 연속적으로 붙어있는것이아닌
자유분방하게 흩뿌려져있는 노드의 형태이기때문에

아마 배열첨자를 못쓰는 이유도 이런 이유가 아닐까 싶다


Container.sort(); 
컨테이너 형태는 가능 



Container.sort([](const int&, const int& b)
		{
			return a > b; // 이값을 이용해서 내림차순 오름차순으로 변경가능
		});




################################################################################

bool을 반환하는 함수 : predicate

자주쓰는 기능 

Container.sort(std::less());  // 작냐 
Container.sort(std::less_eqaul()); // 작거나 같으냐
Container.sort(std::equal()); //같으냐

머 greater  , greater_equal  크냐 크거나 같으냐도 있으니깐

좀더 짧은 코딩이 가능해지니깐
이기능을 자주 사용하자



즉

Container.sort([](const int&, const int& b)
		{
			return a > b; // 이값을 이용해서 내림차순 오름차순으로 변경가능
		});



		이걸


Container.sort(std::less<int>());

이렇게 사용가능합니다.

Container.sort(std::greater<int>());

이건 반대로



#######################################################################################

정리

---------------------------------------------------------------------
std::array
---------------------------------------------------------------------
	- Sequence Container : 순차 컨테이너
	- Contiquos : 연속된 메모리 공간
	- Fixed Size : 고정 크기
	- 배열 대신 사용

	표현식>
	예
	std::array<int, 4> intArray{0,1,2,3};
	<int, 4> 타입의 크기와, 배열의 크기


---------------------------------------------------------------------
std::vector
---------------------------------------------------------------------

	- Sequential 순차적 컨테이너

	- Contiguous    / Allocator
연속적인 메모리공간 / 상황에따라 동적으로 할당할수있다

	- Dynamic Size
		동적 사이즈

	- 동적배열 - 뒤에 원소가 추가되거나 삭제되는 경우
	 원소의 추가 / 삭제가 뒤에서 일어날때


---------------------------------------------------------------------
std::forward_list
---------------------------------------------------------------------

	- Sequential 원소는 정해진 순서대로 저장된다 // 순차적

	- single linked list // 이 이유때문에 배열첨자가 사용이 불가능하다

	- 연속된 메모리를 차지하진않는다

	- 동적

	벡터와 같이
	중간에 원소를 삽입할수는 있지만
	원소의 추가/삭제가 뒤에서 일어날때가 가장 빠르다
	벡터보다는 추가/삭제가 자유롭다
	리스트

!!!리스트는 배열첨자 사용이 불가능하다
그렇기 때문에 컨테이너의 기능중에 정렬같은 기능은 사용하지못한다

Contiguous 의 형태가 아니면 사용이 불가능 하다고 보면될듯

순차적인 형태인거지 실제로 메모리에 연속적으로 배열돼있는건 아니니깐

---------------------------------------------------------------------


*/
